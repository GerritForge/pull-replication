// Copyright (C) 2025 GerritForge, Inc.
//
// Licensed under the BSL 1.1 (the "License");
// you may not use this file except in compliance with the License.
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package com.gerritforge.gerrit.plugins.replication.pull.api;

import static com.google.common.truth.Truth.assertThat;
import static org.apache.http.HttpStatus.SC_OK;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.anyList;
import static org.mockito.ArgumentMatchers.anyLong;
import static org.mockito.ArgumentMatchers.anyString;
import static org.mockito.Mockito.doThrow;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

import com.gerritforge.gerrit.plugins.replication.pull.api.data.RevisionData;
import com.gerritforge.gerrit.plugins.replication.pull.api.data.RevisionInput;
import com.gerritforge.gerrit.plugins.replication.pull.api.data.RevisionObjectData;
import com.gerritforge.gerrit.plugins.replication.pull.api.exception.MissingParentObjectException;
import com.google.common.collect.Lists;
import com.google.gerrit.entities.Project;
import com.google.gerrit.extensions.restapi.Response;
import com.google.gerrit.extensions.restapi.RestApiException;
import com.google.gerrit.server.project.ProjectResource;
import java.util.Collections;
import java.util.List;
import org.eclipse.jgit.lib.Constants;
import org.eclipse.jgit.lib.ObjectId;
import org.junit.Before;
import org.junit.Ignore;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.Mock;
import org.mockito.junit.MockitoJUnitRunner;

@RunWith(MockitoJUnitRunner.class)
public class BatchApplyObjectActionTest {

  private static final long DUMMY_EVENT_TIMESTAMP = 1684875939;

  private BatchApplyObjectAction batchApplyObjectAction;
  private static final String LABEL = "instance-2-label";
  private static final String REF_NAME = "refs/heads/master";
  private static final String REF_META_NAME = "refs/meta/version";
  private static final String SAMPLE_COMMIT_OBJECT_ID = "9f8d52853089a3cf00c02ff7bd0817bd4353a95a";
  private static final String SAMPLE_TREE_OBJECT_ID = "4b825dc642cb6eb9a060e54bf8d69288fbee4904";

  private static final String SAMPLE_COMMIT_CONTENT =
      "tree "
          + SAMPLE_TREE_OBJECT_ID
          + "\n"
          + "parent 20eb48d28be86dc88fb4bef747f08de0fbefe12d\n"
          + "author Gerrit User 1000000 <1000000@69ec38f0-350e-4d9c-96d4-bc956f2faaac> 1610471611"
          + " +0100\n"
          + "committer Gerrit Code Review <root@maczech-XPS-15> 1610471611 +0100\n"
          + "\n"
          + "Update patch set 1\n"
          + "\n"
          + "Change has been successfully merged by Administrator\n"
          + "\n"
          + "Patch-set: 1\n"
          + "Status: merged\n"
          + "Tag: autogenerated:gerrit:merged\n"
          + "Reviewer: Gerrit User 1000000 <1000000@69ec38f0-350e-4d9c-96d4-bc956f2faaac>\n"
          + "Label: SUBM=+1\n"
          + "Submission-id: 1904-1610471611558-783c0a2f\n"
          + "Submitted-with: OK\n"
          + "Submitted-with: OK: Code-Review: Gerrit User 1000000"
          + " <1000000@69ec38f0-350e-4d9c-96d4-bc956f2faaac>";

  @Mock private ApplyObjectCommand applyObjectCommand;
  @Mock private ProjectResource projectResource;
  @Mock FetchPreconditions preConditions;

  @Before
  public void setup() throws Exception {
    batchApplyObjectAction =
        new BatchApplyObjectAction(
            applyObjectCommand, new ApplyObjectInputValidator(preConditions));
    when(projectResource.getNameKey()).thenReturn(Project.nameKey("project"));
    when(preConditions.canCallFetchApi()).thenReturn(true);
  }

  @Test
  public void shouldCallBatchApplyObjectsWithExpectedArguments() throws Exception {
    RevisionInput first =
        new RevisionInput(LABEL, REF_NAME, DUMMY_EVENT_TIMESTAMP, createSampleRevisionData());
    RevisionInput second =
        new RevisionInput(LABEL, "foo", DUMMY_EVENT_TIMESTAMP, createSampleRevisionData());

    batchApplyObjectAction.apply(projectResource, List.of(first, second));

    // TODO: Proper equality checks here!
    verify(applyObjectCommand)
        .batchApplyObjects(any(), any(), anyList(), anyList(), anyString(), anyLong());
  }

  @Test
  public void shouldReturnOkResponseCodeWhenAllRevisionsAreProcessedSuccessfully()
      throws RestApiException {
    RevisionInput first =
        new RevisionInput(LABEL, REF_NAME, DUMMY_EVENT_TIMESTAMP, createSampleRevisionData());
    RevisionInput second =
        new RevisionInput(LABEL, "foo", DUMMY_EVENT_TIMESTAMP, createSampleRevisionData());

    Response<?> response = batchApplyObjectAction.apply(projectResource, List.of(first, second));

    assertThat(response.statusCode()).isEqualTo(SC_OK);
  }

  @Ignore("Can revision input actually be null?")
  public void shouldReturnOneOkCodeEvenIfInputContainsBothCreatesAndDeletes()
      throws RestApiException {
    RevisionInput create =
        new RevisionInput(LABEL, REF_NAME, DUMMY_EVENT_TIMESTAMP, createSampleRevisionData());
    RevisionInput delete = new RevisionInput(LABEL, REF_META_NAME, DUMMY_EVENT_TIMESTAMP + 1, null);

    List<RevisionInput> inputs = List.of(create, delete);

    Response<?> response = batchApplyObjectAction.apply(projectResource, inputs);

    assertThat(response.statusCode()).isEqualTo(SC_OK);
  }

  @Test(expected = RestApiException.class)
  public void shouldThrowARestApiExceptionIfProcessingFailsForAnyOfTheRevisions() throws Exception {
    RevisionInput good =
        new RevisionInput(LABEL, REF_NAME, DUMMY_EVENT_TIMESTAMP, createSampleRevisionData());
    RevisionInput bad =
        new RevisionInput(LABEL, "bad", DUMMY_EVENT_TIMESTAMP, createSampleRevisionData());

    doThrow(
            new MissingParentObjectException(
                projectResource.getNameKey(), REF_NAME, ObjectId.zeroId()))
        .when(applyObjectCommand)
        .batchApplyObjects(any(), any(), anyList(), anyList(), anyString(), anyLong());

    batchApplyObjectAction.apply(projectResource, List.of(good, bad));
  }

  private RevisionData createSampleRevisionData() {
    RevisionObjectData commitData =
        new RevisionObjectData(
            SAMPLE_COMMIT_OBJECT_ID, Constants.OBJ_COMMIT, SAMPLE_COMMIT_CONTENT.getBytes());
    RevisionObjectData treeData =
        new RevisionObjectData(SAMPLE_TREE_OBJECT_ID, Constants.OBJ_TREE, new byte[] {});
    return createSampleRevisionData(commitData, treeData);
  }

  private RevisionData createSampleRevisionData(
      RevisionObjectData commitData, RevisionObjectData treeData) {
    return new RevisionData(Collections.emptyList(), commitData, treeData, Lists.newArrayList());
  }
}
